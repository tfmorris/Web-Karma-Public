/*******************************************************************************
 * Copyright 2012 University of Southern California
 * 
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *  
 *    This code was developed by the Information Integration Group as part 
 *    of the Karma project at the Information Sciences Institute of the 
 *    University of Southern California.  For more information, publications, 
 *    and related projects, please see: http://www.isi.edu/integration
 ******************************************************************************/

package edu.isi.mediator.rdf;

import java.io.PrintWriter;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import edu.isi.mediator.gav.main.MediatorException;
import edu.isi.mediator.gav.util.MediatorLogger;

public class RDFUtil {

	private static final MediatorLogger logger = MediatorLogger.getLogger(RDFUtil.class.getName());

	/**
	 * Write namespaces to output.
	 */
	static public void setNamespace(Map<String,String> sourceNamespaces, Map<String,String> ontologyNamespaces, 
			PrintWriter outWriter) throws MediatorException{
		Iterator<String> keys1 = ontologyNamespaces.keySet().iterator();
		while(keys1.hasNext()){
			String key = keys1.next();
			String prefix = "@prefix " + key + ": <" + ontologyNamespaces.get(key) + "> .";
			outWriter.println(prefix);
		}
		Iterator<String> keys2 = sourceNamespaces.keySet().iterator();
		while(keys2.hasNext()){
			String key = keys2.next();
			String prefix = "@prefix " + key + ": <" + sourceNamespaces.get(key) + "> .";
			outWriter.println(prefix);
		}
		//outWriter.println();
	}


	/**
	 * Return the prefix for a given namespace IF the map contains only one entry.
	 * @param namespaces
	 * 		map containing namespaces
	 * @return
	 * 		the prefix for a given namespace IF the map contains only one entry
	 * 		null otherwise
	 */
	static public String getPrefix(Map<String,String> namespaces){
		Set<Entry<String,String>> entries = namespaces.entrySet();
		if(entries.size()==1){
			//return the unique key
			Iterator<Entry<String,String>> it = entries.iterator();
			Entry<String,String> e = it.next();
			return (String)e.getKey();
		}
		else{
			return null;
		}
	}

	/**
	 * Returns the table name from a given URI.
	 * Table name appears as: DBNAME.TableName/ or /TableName/
	 * @param uri
	 * 		the uri (it is a URI generated by D2R)
	 * @return
	 * @throws MediatorException
	 */
	static public String getTableName(String uri) throws MediatorException{
		
		String tokens[] = uri.split("/");
		
		if(tokens.length<2){
			throw new MediatorException("The URI must contain a table name either as DBNAME.TableName/ or /TableName/.");
		}
		
		String tableName = tokens[tokens.length-2];
		
		logger.debug("TableName=" + tableName);
		int ind = tableName.indexOf(".");

		if(ind>0){
			tableName = tableName.substring(ind+1);
		}
		logger.debug("TableName=" + tableName);
		
		return tableName;
	}

	/**
	 * Returns the table name from a given URI.
	 * Table name appears as: DBNAME.TableName/
	 * @param uri
	 * 		the uri (it is a URI generated by D2R)
	 * @return
	 * @throws MediatorException
	 */
	static public String getTableNameOracle(String uri) throws MediatorException{
		
		//the "." is the start of the table name
		int ind1 = uri.lastIndexOf(".");
		//System.out.println("getTableName:" + uri + " ind=" + ind1);
		if(ind1<0){
			throw new MediatorException("The URI must contain a table name that starts with \".\"");
		}
		int ind2 = uri.indexOf("/", ind1);
		if(ind2<0){
			throw new MediatorException("The subject URI must contain a table name that starts with \".\" and ends with \"/\". /DBName.TableName/");
		}
		String tableName = uri.substring(ind1+1, ind2);
		//System.out.println("TableName:" + tableName);
		
		return tableName;
	}

	/**
	 * Returns the database name from a given URI.
	 * database name appears as: /DBNAME.TableName/
	 * @param uri
	 * 		the uri (it is a URI generated by D2R)
	 * @return
	 * @throws MediatorException
	 */
	static public String getDatabaseName(String uri) throws MediatorException{
		
		String tokens[] = uri.split("/");
		
		if(tokens.length<2){
			throw new MediatorException("The URI must contain a table name either as DBNAME.TableName/ or /TableName/.");
		}
		
		String dbName = tokens[tokens.length-2];
		
		logger.debug("TableName=" + dbName);
		int ind = dbName.indexOf(".");

		if(ind>0){
			dbName = dbName.substring(0, ind) + ".";
		}else{
			dbName = "";
		}
		
		logger.debug("Database name=" + dbName);
		
		return dbName;

	}

	/**
	 * Returns the database name from a given URI.
	 * database name appears as: /DBNAME.TableName/
	 * @param uri
	 * 		the uri (it is a URI generated by D2R)
	 * @return
	 * @throws MediatorException
	 */
	static public String getDatabaseNameOracle(String uri) throws MediatorException{
		
		//the "." is the start of the table name
		int ind1 = uri.lastIndexOf(".");
		//System.out.println("getTableName:" + uri + " ind=" + ind1);
		if(ind1<0){
			throw new MediatorException("The URI must contain a table name that starts with \".\"");
		}
		//set the database name
		int ind3 = uri.lastIndexOf("/", ind1);
		return uri.substring(ind3+1,ind1);
	}

	/**
	 * Returns a generic symbol.
	 * @param uniqueId
	 * 		uniqueid - usually the time
	 * @param rowId
	 * @param value
	 * @return
	 * 		a generic symbol.
	 */
	static public String gensym(String uniqueId, int rowId, String value){
		return uniqueId + "r" + String.valueOf(rowId) + "_" + value;
	}
	
	static public String escapeQuote(String s){
		s = s.replaceAll("\"", "\\\\\"");
		s = s.replaceAll("\r\n", " ");
		return "\"" + s + "\"";
	}
	

}
