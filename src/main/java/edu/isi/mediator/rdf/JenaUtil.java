/*******************************************************************************
 * Copyright 2012 University of Southern California
 * 
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * 
 *        http://www.apache.org/licenses/LICENSE-2.0
 * 
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *  
 *    This code was developed by the Information Integration Group as part 
 *    of the Karma project at the Information Sciences Institute of the 
 *    University of Southern California.  For more information, publications, 
 *    and related projects, please see: http://www.isi.edu/integration
 ******************************************************************************/

package edu.isi.mediator.rdf;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QueryExecutionFactory;
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.QuerySolution;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.rdf.model.Literal;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.RDFNode;

import edu.isi.mediator.gav.main.MediatorException;
import edu.isi.mediator.gav.util.MediatorLogger;


/**
 * Class that provides JENA utility methods
 * 
 * @author Maria Muslea(USC/ISI)
 *
 */
public class JenaUtil {
	
	private static final MediatorLogger logger = MediatorLogger.getLogger(JenaUtil.class.getName());

	/** Returns the prefix with the given name.
	 * @param model
	 * 		RDF model
	 * @param prefixName
	 * 		prefix name
	 * @return
	 * 		the prefix with the given name. Throws an exception if the prefix cannot be found.
	 * @throws MediatorException 
	 */
	static public String getNamespace(Model model, String prefixName) throws MediatorException{
		//get vocab prefix; used in query
		Map<String, String> allPref = model.getNsPrefixMap();
		//System.out.println("prefix="+allPref);
		String prefix = allPref.get(prefixName);
		if(prefix==null){
			throw new MediatorException("The prefix " + prefixName + " cannot be found!");
		}
		return prefix;
	}

	/**
	 * Returns the namespace of properties related to the input URI.
	 * <br> Get the properties if the input URI, and extract the namespace.
	 * @param model
	 * 		RDF model
	 * @param uri
	 * @param tableName
	 * 		the table that contains the objects referred to in the URI.
	 * @return
	 * 		the namespace of properties related to the input URI.
	 * @throws MediatorException
	 */
	static public String getNamespace(Model model, String uri, String tableName) throws MediatorException{
		String propertyPrefix = "";
		String q = "SELECT DISTINCT ?p WHERE {" +
				" <" + uri + "> ?p ?o . }"; 
		List<Map<String, String>> propertyValues = executeQueryExtractValues(model, q);
		logger.debug("Found properties=" +  propertyValues);
		for(int i=0; i<propertyValues.size(); i++){
			Map<String, String> prop = propertyValues.get(i);
			String propertyValue = prop.get("p");
			if(propertyValue.contains(tableName)){
				//extract the prefix
				int ind1 = propertyValue.indexOf("http");
				int ind2 = propertyValue.lastIndexOf("/");
				if(ind1>=0 && ind2>0){
					propertyPrefix = propertyValue.substring(ind1,ind2+1);
				}
			}
		}
		logger.debug("Property Prefix=" +  propertyPrefix);
		return propertyPrefix;
	}
	
	/**
	 * Returns attr/value pairs for all tuples generated by executing the query.
	 * <br> For values that are URI, it marks the URI to distinguish between literals that are a URI (start with http)
	 *  and an actual resource URI(see getOneRowMarkURI()).
	 * @param model
	 * 		RDF model
	 * @param q
	 * 		SPARQL query
	 * @return
	 * 		attr/value pairs for all tuples generated by executing the query.
	 * @throws MediatorException
	 */
	static public List<Map<String, String>> executeQueryExtractValues(Model model, String q) throws MediatorException{
		List<Map<String, String>> allRows = new ArrayList<Map<String, String>>();
		logger.info("Execute SPARQL query ... (may take a few minutes)");
		logger.debug("Execute SPARQL query ... " + q);
		// Execute the query and obtain results
		Query query = QueryFactory.create(q);
		QueryExecution qe = QueryExecutionFactory.create(query, model);
		ResultSet results = qe.execSelect();

		List<String> vars = results.getResultVars();
		int i=0;
		while(results.hasNext()){
			if(i==0){
				logger.info("Process Results ...");
			}
			//it is streaming the solutions, so as soon as we have a solution it returns it
			//but then you wait until the next solution is returned.
			QuerySolution qs = results.nextSolution();
			Map<String, String> oneRow = getOneRowMarkURI(qs, vars);
			//System.out.println("ONEROW="+oneRow);
			allRows.add(oneRow);
			i++;
		}
		logger.debug("Processed " + i + " rows.");
			
		return allRows;
	}

	/**
	 * Returns attr/value pairs for all tuples generated by executing the query.
	 * @param model
	 * 		RDF model
	 * @param q
	 * 		SPARQL query
	 * @return
	 * 		attr/value pairs for all tuples generated by executing the query.
	 * @throws MediatorException
	 */
	static public List<Map<String, String>> executeQuery(Model model, String q) throws MediatorException{
		List<Map<String, String>> allRows = new ArrayList<Map<String, String>>();
		logger.debug("Execute SPARQL query ..." + q);
		// Execute the query and obtain results
		Query query = QueryFactory.create(q);
		QueryExecution qe = QueryExecutionFactory.create(query, model);
		ResultSet results = qe.execSelect();

		List<String> vars = results.getResultVars();
		int i=0;
		while(results.hasNext()){
			if(i==0){
				//System.out.println("Process Results ...");
			}
			QuerySolution qs = results.nextSolution();
			Map<String, String> oneRow = getOneRow(qs, vars, true);
			//System.out.println("SD ONEROW="+oneRow);
			allRows.add(oneRow);
			i++;
		}
		//System.out.println("Processed " + i + " rows.");
		return allRows;
	}

	/** Returns attr/value pairs for one row of data.
	 * @param qs
	 * 		represents one row of data.
	 * @param vars
	 * 		a list of variables returned by the query.
	 * @param valueAsURI
	 * 		true if the value is returned as is: URI or Literal
	 * 		false if we extract the value from the URI
	 * @return
	 * 		attr/value pairs for one row of data.
	 * @throws MediatorException
	 */
	static private Map<String, String> getOneRow(QuerySolution qs, List<String> vars, boolean valueAsURI) throws MediatorException {
		Map<String, String> onerow = new HashMap<String, String>();
		for(int j=0; j<vars.size(); j++){
			String var = vars.get(j);
			RDFNode node = qs.get(var);
			if(node == null){
				//property didn't exist; equivalent to NULL value in DB
				onerow.put(var, "NULL");				
			}
			else if(node.isLiteral()){
				//I have the actual values
				onerow.put(var, ((Literal)node).getString());
				//System.out.println("VAR=" + var + " Val=" + node.toString());
			}
			else {
				//it's a URI/Resource, so I have to extract the value
				if(valueAsURI){
					onerow.put(var, node.toString());
				}
				else {
					onerow.put(var, getValueFromUri(node.toString()));
				//System.out.println("VAR=" + var + " Val=" + node.toString());
				}
			}

		}
		return onerow;
	}

	static private Map<String, String> getOneRowMarkURI(QuerySolution qs, List<String> vars) throws MediatorException {
		Map<String, String> onerow = new HashMap<String, String>();
		for(int j=0; j<vars.size(); j++){
			String var = vars.get(j);
			RDFNode node = qs.get(var);
			if(node == null){
				//property didn't exist; equivalent to NULL value in DB
				onerow.put(var, "NULL");				
				//System.out.println("VAR=" + var + " Val=" + "NULL");
			}
			else if(node.isLiteral()){
				//I have the actual values
				onerow.put(var, ((Literal)node).getString());
				//System.out.println("VAR=" + var + " Val=" + node.toString());
			}
			else {
				//mark to know that it is a URI
				//I need to know this in the uri(), so I don't confuse a URI with a literal value
				//that is a URL
				onerow.put(var, RuleRDFMapper.URI_FLAG + node.toString());
				//System.out.println("VAR=" + var + " Val=" + node.toString());
			}

		}
		return onerow;
	}

	/**
	 * Returns the value from a URI.
	 * <br>The URI should contain DbName.TableName/Value
	 * <br>Look for last "."; this is the beginning of the table name
	 * <br>from there search for "/" (not sure what happens if the table name contains /)
	 * @param uri
	 * 		the URI.
	 * @return
	 * 		the value from a URI.
	 * @throws MediatorException 
	 */
	static private String getValueFromUri(String uri) throws MediatorException{
		//look for "."; this is the beginning of the table name
		//from there search for "/" (not sure what happens if the table name contains /)
		int ind1 = uri.toString().lastIndexOf(".");
		//System.out.println("getValueFromUri:" + uri + " ind=" + ind1);
		if(ind1<0){
			throw new MediatorException("The subject URI must contain a table name that starts with \"DBNAME.\"");
		}
		int ind2 = uri.toString().indexOf("/", ind1);
		if(ind2<0){
			throw new MediatorException("The subject URI must contain a table name that starts with \".\" and ends with \"/\", and a value." +
										" /DBName.TableName/Value");
		}
		String value = uri.toString().substring(ind2+1);
		return value;
		
	}
}
